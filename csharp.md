# Соглашение по оформлению исходного кода на языке C#
## Список терминов

В русском языке есть некоторые разночтения в названии некоторых частей программы. Во избежание путаницы в этом разделе будут приведены часто встречающиеся термины, их английские аналоги и краткое пояснение.

- operator – оператор (например, +, -, *, !)
- statement – инструкция (например, «a = b;», «if (a) {}»)
- expression – выражение (например, «a – b + c», «a == 1»)

## Именование идентификаторов

- Помните! Код чаще читается, чем пишется, поэтому не экономьте на понятности и чистоте кода ради скорости набора.

- Не используйте малопонятные префиксы или суффиксы (например, венгерскую нотацию), современные языки и средства разработки позволяют контролировать типы данных на этапе разработки и сборки.

- Не используйте подчеркивание для отделения слов внутри идентификаторов, это удлиняет идентификаторы и затрудняет чтение. Вместо этого используйте стиль именования Кэмэл или Паскаль.

- Старайтесь не использовать сокращения лишний раз, помните о тех, кто читает код.

- Старайтесь делать имена идентификаторов как можно короче (но не в ущерб читабельности). Помните, что современные языки позволяют формировать имя из пространств имен и типов. Главное, чтобы смысл идентификатора был понятен в используемом контексте. Например, количество элементов коллекции лучше назвать Count, а не CountOfElementsInMyCollection.

- Когда придумываете название для нового, общедоступного (public) класса, пространства имен или интерфейса, старайтесь не использовать имена, потенциально или явно конфликтующие со стандартными идентификаторами.

- Предпочтительно использовать имена, которые ясно и четко описывают предназначение и/или смысл сущности.

- Старайтесь не использовать для разных сущностей имена, отличающиеся только регистром букв. Разрабатываемые вами компоненты могут быть использованы из языков, не различающих регистр, и некоторые методы (или даже весь компонент) окажутся недоступными.

- Старайтесь использовать имена с простым написанием. Их легче читать и набирать. Избегайте (в разумных пределах) использования слов с двойными буквами, сложным чередованием согласных. Прежде, чем остановиться в выборе имени, убедитесь, что оно легко пишется и однозначно воспринимается на слух. Если оно с трудом читается, и вы ошибаетесь при его наборе, возможно, стоит выбрать другое.

### Стили использования регистра букв

**Паскаль** – указание этого стиля оформления идентификатора обозначает, что первая буква заглавная и все последующие первые буквы слов тоже заглавные. Например, BackColor, LastModified, DateTime.

**Кэмел** – указание этого стиля обозначает, что первая буква строчная, а остальные первые буквы слов  заглавные. Например, borderColor, accessTime, templateName.

### Сокращения

- Не используйте аббревиатуры или неполные слова в идентификаторах, если только они не являются общепринятыми. Например, пишите GetWindow, а не GetWin.

- Не используйте акронимы, если они не общеприняты в области информационных технологий.

- Широко распространенные акронимы используйте для замены длинных фраз. Например, UI вместо User Interface или Olap вместо On-line Analytical Processing.

- Если имеется идентификатор длиной менее трех букв, являющийся сокращением, то его записывают заглавными буквами, например System.IO, System.Web.UI. Имена длиннее двух букв записывайте в стиле Паскаль или Кэмел, например Guid, Xml, xmlDocument.

```cs

using System.IO;

using System.Web.UI;

public class Math

{
    public const PI = ...;

    public const E = ...;
}
```
### Выбор слов

Не используйте имена, совпадающие с глобальными пространствами имен, такими, как System и Microsoft. Старайтесь по возможности избегать совпадения с названиями других сущностей .NET Framework.

Ниже приводится список имен, использование которых нежелательно:
```cs
AddHandler AddressOf Alias And Ansi

As Assembly Auto Base Boolean

ByRef Byte ByVal Call Case

Catch CBool CByte CChar CDate

CDec CDbl Char CInt Class

CLng CObj Const CShort CSng

CStr CType Date Decimal Declare

Default Delegate Dim Do Double

Each Else ElseIf End Enum

Erase Error Event Exit ExternalSource

False Finalize Finally Float For

Friend Function Get GetType Goto

Handles If Implements Imports In

Inherits Integer Interface Is Let

Lib Like Long Loop Me

Mod Module MustInherit MustOverride MyBase

MyClass Namespace New Next Not

Nothing NotInheritable NotOverridable Object On

Option Optional Or Overloads Overridable

Overrides ParamArray Preserve Private Property

Protected Public RaiseEvent ReadOnly ReDim

Region REM RemoveHandler Resume Return

Select Set Shadows Shared Short

Single Static Step Stop String

Structure Sub SyncLock Then Throw

To True Try TypeOf Unicode

Until volatile When While With

WithEvents WriteOnly Xor eval extends

instanceof package var
```
## Пространства имен

- Для пространства имен используйте имя компании, затем название продукта и, возможно, название подсистемы или существенной части проекта. Например, Ksoft.Framework, Ksoft.MegaTool.Scanner.

- Используйте стиль Паскаль для регистра букв.
- При объявлении пространства имен используйте единственную директиву namespace с полным именем пространства имен. Не используйте вложенные объявления пространств имен. Это замечание не относится к С++/MС++, так как в них нет отличной от вложенных пространств имен возможности создавать составные пространства имен.

- Множественное число следует использовать в случае, если пространство имен объединяет некоторое количество разных, но семантически похожих сущностей. И наоборот, когда пространство имен содержит некую подсистему, стоит использовать единственное число.

     ```cs
     namespace Ksoft.Collections {} //good
     namespace Ksoft.Collection {} //wrong
     
     namespace Ksoft.Controls {} // good
     namespace Ksoft.Control {} //wrong
     
     namespace Ksoft.Network {} //good
     namespace Ksoft.Networks {} //wrong 
     
     namespace Ksoft.Web {} //good
     namespace Ksoft.Webs {} //wrong
     ```

- Не используйте одно и то же имя для класса и пространства имен. Например, не используйте класс Debug и пространство имен Debug.
    ```cs
    namespace Ksoft.Controls {}
    
    namespace Ksoft.Collections {}
    
    namespace Ksoft.Common {}
    
    namespace Ksoft.Network {}
    ```

- Перечислять импортируемые пространства имен необходимо в следующей последовательности: пространства имен .NET Framework, пространства имен сторонних производителей, собственные пространства имен из других проектов, пространства имен из текущего проекта. Каждый такой раздел должен отделяться одной пустой строкой, а имена внутри раздела должны быть отсортированы по алфавиту.

- Директивы using, содержащие alias, должны идти в конце соответствующих разделов, и также быть упорядоченными по алфавиту.

### Типы

- Все не вложенные типы (размещаемые в пространствах имен или непосредственно в глобальном пространстве), за исключением делегатов, должны находиться в отдельных файлах.

- Старайтесь объявлять вложенные типы в начале внешнего типа.

- Старайтесь не делать излишней вложенности типов. Помните, что вложенными должны быть только тесно связанные типы.

- Элементы типов должны отделяться одной строкой друг от друга. Вложенные типы должны отделяться двумя строками. При объявлении большого количества полей, используемых внутри класса (не публичных), можно опускать пустую строку (особенно если поля отделены XML-комментариями).

### Классы/Структуры

- Используйте существительное (одно или несколько прилагательных и существительное) для имени класса.

- Используйте стиль Паскаль для регистра букв.

- Не используйте специальных префиксов, поясняющих, что это класс. Например, FileStream, а не CFileStream.

- В подходящих случаях используйте составные слова для производных классов, где вторая часть слова поясняет базовый класс. К примеру, ApplicationException – вполне подходящее название для класса, унаследованного от Exception, поскольку ApplicationException является наследником класса Exception. Не стоит, однако злоупотреблять этим методом, пользуйтесь им разумно. К примеру, Button – вполне подходящее название для класса, производного от Control. Общее правило может быть, например, таким: «Если производный класс незначительно меняет свойства, поведение или внешний вид базового, используйте составные слова. Если класс значительно расширяет или меняет поведение базового, используйте новое существительное, отражающее суть производного класса». LinkLabel незначительно меняет внешний вид и поведение Label и, соответственно, использует составное имя.
 
- Используйте составное имя, когда класс принадлежит некоторой специфичной категории, например FileStream, StringCollection, IntegrityException. Это  относится  к  классам, которые являются потоками (Stream), коллекциями (Collection, Queue, Stack), ассоциативными контейнерами (Dictionary), исключениями (Exception).

- Для классов-наследников, реализующих интерфейс IDictionary рекомендуется использовать тройное имя в виде <ТипКлюча>To<ТипЗначения>Dictionary. Вместо Dictionary можно использовать слово Map. Если это очевидно, можно опускать название значения. Примеры: StringToStringDictionary, StringToIntegerMap или KeywordMap. Переменным такого типа рекомендуется давать более конкретное семантическое название, например userToPasswordMap (user --> password), nameServiceDictionary (name --> service).

- Для базового класса, предназначенного не для прямого использования, а для наследования, следует использовать суффикс Base. Например, CollectionBase. Такие классы также стоит делать абстрактными.

- Коллекциям (реализующим интерфейс ICollection/IList) нужно давать имя в виде <ИмяЭлемента>Collection. Переменным же этих типов лучше давать имена, являющиеся множественным числом от элемента. Например, коллекция кнопок должна иметь имя ButtonCollection, а переменная buttons.

    ```cs
    public class FileStream {}
    public class Button {}
    public class String {}
    public class StringCollection {}
    ```
### Интерфейсы

- Используйте описывающее существительное, прилагательное или одно или несколько прилагательных и существительное для идентификатора интерфейса. Например, IComponent – это описывающее cуществительное, ICustomAttributeProvider – это конкретизированное прилагательными существительное, а IPersistable – это характеризующее прилагательное.

- Используйте стиль Паскаль для регистра букв.

- Используйте префикс I (заглавная i) для интерфейсов, чтобы уточнить, что тип является интерфейсом. Старайтесь избегать интерфейсов с двумя I в начале, например IIdentifiable. Попробуйте подобрать синоним, например IRecognizable.

- Для пары класс-интерфейс, в которой класс является некоторой стандартной или эталонной реализацией интерфейса, используйте одинаковые имена, отличающиеся только префиксом I для интерфейса. Например, IConfigurationManager и ConfigurationManager.
    ```cs
    public interface IServiceProvider {}
    
    public interface IFormatable {}
    
    public interface IComponent
    {
        // Объявление  интерфейса
    }
    
    public class Component : IComponent // Стандартная  реализация  интерфейса
    {
        // Реализация
    }
    ```

### Атрибуты

- Класс, являющийся атрибутом, должен иметь суффикс Attribute. Ни один класс, атрибутом не являющийся, не должен иметь такого суффикса. Если семантика класса требует в названии слова что-то вроде Attribute, используйте синонимы, например Descriptor, Sign, Qualifier, Specifier, Declarator.
    ```cs
    public class ObsoleteAttribute {};
    ```

### Перечисления

- Используйте стиль Паскаль для регистра букв в названии и значениях перечисления.

- Не используйте суффикс Enum в названии типа, вместо этого используйте более конкретный суффикс, например Style, Type, Mode, State. Чтобы код легче читался, используйте следующее правило: «Название перечисления + is + значение должно образовывать простое предложение». Например: BorderStyle.Single ( Border style is single, ThreadState.Aborted --> Thread state is “aborted”.

- Если перечисление обладает атрибутом [Flags], используйте множественное число или суффикс Flags.

- Записывайте значения перечисления на отдельных строках. Если элементы имеют определенный семантический порядок, описывайте их именно так, иначе используйте алфавитный порядок.

5. Если значение одного из членов перечисления зависит от других, используйте булевы

операции (&, |, ^), а не литеральные константы.

6. Имена членов перечисления не должны содержать имени перечисления и другой не

относящейся к конкретному значению информации.

Пример:

public enum CodeStyle

{

Good,

Normal,

Bad,

Ugly

}

2.9 Поля

1. Непубличные  поля (private, protected и protected internal) именуются  в  стиле  Кэмел  и

начинаются с префикса _.

2. Публичные поля именуются в соответствии с правилами именования свойств.

7

3. Одна декларация должна содержать не более одного поля и должна располагаться на

одной строке.

Верно Неверно

class A

{

int _var1;

int _var2;

...

}

class A

{

int _var1,

_var2;

...

}

class A

{

int _var1, _var2;

...

}

4. Публичные поля должны в обязательном порядке документироваться XML<![if !supportFootnotes]>[1]<![endif]>комментариями. Желательно снабжать XML-комментариями и непубличные поля.

5. Обращаясь к публичным полям старайтесь избегать их передачи по ссылке, т.к. велика

вероятность того, что в следующих версиях приложения эти поля могут стать свойствами.

2.10 Методы

1. Используйте глаголы или комбинацию глагола и существительных и прилагательных для

имен методов.

2. Используйте стиль Паскаль для регистра букв (вне зависимости от области видимости

метода).

Примеры:

private int RemoveAll() {}

public void GetCharArray() {}

internal static Invoke() {}

2.11 Свойства

1. Используйте существительное или одно или несколько прилагательных и существительное

для имени свойства.

2. Используйте стиль Паскаль для регистра букв.

3. В подходящих случаях используйте имя свойства, совпадающее с типом его значения.

Одним из критериев для применения этого правила является наличие единственного

свойства со значением некоторого (нетривиального) типа.

4. Старайтесь избегать использования имен свойств, совпадающих с названиями каких-либо

типов, если значения этих свойств не являются значениями этих типов. В этом случае будет

трудно получить доступ к статическим членам типа или значениям перечисления.

Например, при использовании конструкции public int Color { get; set; }, обращение

Color.Xxx будет рассматриваться как получение свойства Color и затем доступ к свойствам

или методам этого значения, которое в данном случае будет являться типа System.Int32.

5. Рассмотрите возможность включения имени типа в идентификатор свойства, особенно

если этот тип – перечисление. Например, OuterBorderStyle, BackColor, SocketFlags.

Примеры:

public class SampleClass

{

public Color BackColor

{

// Code for Get and Set accessors goes here.

}

8

}

public class Control

{

public Color Color

{

get {/* Insert code here. */}

set {/* Insert code here. */}

}

}

2.12 События

1. Используйте суффикс EventHandler для делегатов, являющихся типами событий. Другие

классы не должны использовать этот суффикс.

2. Создавая событие в компонентах и control-ах, старайтесь описывать их по следующей

схеме. Определите два параметра с именами sender и e. Параметр sender описывает

объект, инициировавший событие, и всегда должен быть типа object, даже если

возможно использование более конкретного типа. Второй параметр, e, должен содержать

состояние и дополнительную информацию, соответствующую событию. Этот параметр

должен быть конкретного типа, относящегося к событию.

3. Делайте тип, описывающий связанную с событием информацию, производным от

EventArgs, и используйте суффикс EventArgs. Другие классы, не описывающие

информацию о событии, не должны использовать этот суффикс.

4. Для имен событий старайтесь использовать глаголы, которые описывают производимое

над объектом действие (например, Click, GotFocus или FontChanged).

5. Не используйте суффиксы наподобие On, Before, After для идентификатора события.

Используйте соответствующую форму глагола, например Closing перед закрытием и

Closed после закрытия.

6. При описании события также предоставляйте виртуальный protected-метод, который

можно переопределить в классе-наследнике. Называйте такой метод OnXxx, где Xxx – имя

события. В качестве параметров таких методов не следует передавать sender, так как – это

всегда текущий объект (this).

7. Пытайтесь подобрать стандартный делегат и название для своих событий. Например, если

ваш элемент управления должен реагировать на нажатие кнопки мыши, следует

использовать стандартное событие Click. Для элементов управления, обычно, такие

события уже объявлены в базовом классе Control.

Примеры:

public delegate void MouseEventHandler(object sender, MouseEventArgs e);

public class MouseEventArgs : EventArgs

{

private int x;

private int y;

public MouseEventArgs(int x, int y)

{

this.x = x;

this.y = y;

}

public int X { get { return x; } }

public int Y { get { return y; } }

}

public class Control

{

public event MouseEventHandler MouseMove;

protected virtual void OnMouseMove(MouseEventArgs e)

{

if (MouseMove != null)

MouseMove(this, e);

9

}

}

2.13 Параметры

Из имени и типа параметра должны быть понятны его назначение и смысл.

Используйте стиль Кэмел для регистра букв в имени параметра.

Старайтесь избегать указания типа в имени параметра.

Не усложняйте прототип метода «зарезервированными» параметрами, которые, возможно, будут

использоваться в будущих версиях реализации. Если в будущем понадобится новый параметр,

используйте перегрузку методов.

Имена параметров не должны совпадать с именами членов класса. Если этого все же не удается

избежать, используйте ключевое слово this для разрешения конфликтов (допустимо различие в

регистре или префиксе _ для полей классов).

Примеры:

Type GetType(string typeName);

string Format(string format, params object[] args);

3 Стиль кода

3.1 Оформление

1. Используйте табуляцию, а не пробелы для отступов. В средах типа VS лучше использовать

режим табуляции. Его можно настроить в диалоге Options -> Text Editor ->

Ваш_любимый_язык ->Tabs: Indenting = Smart, Tabs = Keep Tabs. В общем, это настройки по

умолчанию для многих языков.

2. При форматировании текста (кроме отступа в начале строки) используйте пробелы. Для

этого удобно использовать режим Virtual Space, который в VS 2002 настраивается в Options

-> Text Editor -> Ваш_любимый_язык -> General.

3. Избегайте строк длиннее 78 символов, переносите инструкцию на другую строку при

необходимости.

4. При переносе части кода инструкций и описаний на другую строку вторая и последующая

строки должны быть отбиты вправо на один отступ (табуляцию).

5. Оставляйте запятую на предыдущей строке так же, как вы это делаете в обычных языках

(русском, например).

6. Избегайте лишних скобок, обрамляющих выражения целиком. Лишние скобки усложняют

восприятие кода и увеличивают возможность ошибки. Если вы не уверены в приоритете

операторов, лучше загляните в соответствующий раздел документации.

7. Не размещайте несколько инструкций на одной строке. Каждая инструкция должна

начинаться с новой строки.

Примеры:

long MethodCall(expr1, expr2, expr3,

expr4, expr5);

var1 = a * b / (c - g + f)

+ 4 * z;

var2 = (a * (b

* (c + d)

+ e * (f / z))

+ 4);

10

3.2 Пустые строки

1. Используйте две пустые строки между логическими секциями в исходном файле.

2. Используйте две пустые строки между объявлениями классов и интерфейсов.

3. Используйте одну пустую строку между методами.

4. Если переменные в методе объявляются отдельным блоком, используйте одну пустую

строку между их объявлением и инструкцией, идущей за этим блоком.

5. Используйте одну пустую строку между логическими частями в методе.

3.3 Пробелы в строке

1. После запятой должен быть пробел. После точки с запятой, если она не последняя в строке

(напр. в инструкции for), должен быть пробел. Перед запятой или точкой с запятой

пробелы не ставятся.

2. Все операторы должны быть отделены пробелом от операндов с обеих сторон.

3. Логически связный блок регулярной структуры желательно форматировать в виде

таблицы. При этом для выравнивания в таблице следует использовать пробелы, но не

табуляцию. Среды типа VS автоматизируют процесс форматирования, вставляя пробелы

или табуляции в соответствии с пользовательскими настройками. Будьте внимательны и

проверяйте конечный результат, включая неотображаемые символы (для VS 2002 и

старше – меню Edit->Advanced->View White Space).

Примеры:

Верно  Неверно

TestMethod(a, b, c); TestMethod( a,b,c );

int Bar { get; set; } int Bar {get;set;}

a = b; a=b;

for (int i = 0; i < 10; ++i)

{

}

for (int i=0;i<10;++i) {}

for( int i = 0 ;i< 10;++i )

if (a == b)

{

}

if(a==b){}

// табличное форматирование

string name = "Mr. Ed";

int myValue = 5;

Test aTest = Test.TestYou;

3.4 Локальные переменные

1. Используйте стиль Кэмел для регистра букв в именах переменных.

2. Объявляйте переменные непосредственно перед их использованием.

3. Счетчики в циклах традиционно называют i, j, k, l, m, n.

4. Для временных локальных переменных, используемых в коротких участках кода, можно

давать имена, состоящие из начальных букв слов имени типа.

5. Не объявляйте более одной переменной в одной инструкции.

6. Имена скрытых (protected, protected internal и private) переменных-членов класса и

статических переменных начинайте с одиночного символа подчеркивания.

7. Имена публичных (internal и public) переменных должны быть в стиле Паскаль и не

иметь подчеркивания в качестве префикса.

8. Комментируйте объявления так, чтобы были понятны назначение и способы

использования переменной.

9. Инициализируйте переменные при объявлении, если это возможно.

Пример:

11

class Class1

{

private int _totalLineCount = 0;

void SomeFunction(int startValue)

{

int lineCount = startValue;

using (StreamReader sr = File.OpenText(@"c:\MyFile.txt"))

{

while (sr.ReadLine() != null)

lineCount++;

}

_totalLineCount = lineCount;

}

}

3.5 Комментарии

1. Не используйте многострочные (/*...*/) комментарии для описания классов и методов,

используйте для этих целей XML documentation-комментарии. Многострочные

комментарии не могут быть вложенными, поэтому их использование может создать

проблемы.

2. Для описания сути некоторого участка кода, пояснений к алгоритму и другой важной

информации используйте несколько подряд идущих однострочных комментариев (//...).

Между группой комментариев и собственно кодом поставьте пустую строку. Это покажет,

что комментарий относится к блоку кода, а не к конкретной инструкции. Напротив, если

комментарий относится к конкретной инструкции, прижмите его вплотную к этой

инструкции.

3. Комментируйте объявления переменных, по возможности используя XML-комментарии.

Если язык не поддерживает XML-комментариев, можно использовать однострочные

комментарии на той же строке, как это показано ниже.

4. Отделяйте текст комментария одним пробелом «// Текст комментария.».

5. Комментируя код, старайтесь объяснять, что он делает, а не какая операция производится.

Так, инструкции if соответствует выражение «если... то...», причем часть, идущая за «то»,

является кодом, который будет выполняться, если выражение в if будет верным. Таким

образом, для конструкции «if (somePath && File.Exists(somePath))», нужно написать

комментарий «// Если выбранный файл существует, то...», а не «// Производим проверку

на наличие файла и, если он имеется, удаляем его». Часть предложения, идущую за «то»,

вписывайте непосредственно перед выполнением конкретных действий. Для инструкций,

осуществляющих действия, пишите «// Производим...» или «// Делаем...», где вместо

троеточия вписывайте описания действий. Описывая действия, старайтесь описывать суть

происходящего, а не то, что делают те или иные операторы. Так, совершенно

бессмысленны комментарии вроде «Присваиваем переменной a значение b» или

«вызываем метод f».

6. Помните, что экономить на комментариях нельзя. Однако не стоит также формально

подходить к процессу создания комментариев. Задача комментария – упростить

понимание кода. Есть немало случаев, когда сам код отличным образом себя

документирует.

Примеры:

/// <summary>indentation level</summary>

int level;

int size; // size of table

// Line 1

//

ArrayList list = new ArrayList(10);

// Line 1

// Line 2

//

12

for (int i = 0; i < list.Count; i++)

...

3.6 Объявления и определения

3.6.1 Объявления классов и интерфейсов

1. Базовые классы и интерфейсы должны указываться на той же строке, что и объявление

класса. Если список не умещается в 78 символов, снесите его, начиная с двоеточия, и

сделайте отступ на одну табуляцию вправо. Размещайте на строке столько элементов,

сколько умещается в 78 символов.

2. Открывающая фигурная скобка должна находиться на строке, следующей за объявлением

класса, на том же уровне отступа, что и класс.

3. Закрывающая фигурная скобка должна находиться на отдельной строке на том же уровне,

что и класс.

4. Содержимое класса должно быть сдвинуто на одну табуляцию относительно объявления.

Пример:

class MySample : MyClass, IMyInterface

{

// содержимое класса

}

3.6.2 Объявления членов класса и интерфейса

1. Между именем метода и открывающей скобкой списка параметров не должно быть

пробела.

2. Тело метода должно быть сдвинуто на одну табуляцию относительно объявления.

3. Вид доступа к члену класса всегда должен быть явно указан.

4. Модификаторы должны идти в следующем порядке: сначала модификаторы доступа, а

потом все остальные.

5. В конструкторе вызов конструктора базового (или этого же) класса (конструкция «:

base(...)» «: this(...)») оформляется таким же образом, как список базовых типов у класса.

Пример:

class MySample : MyClass, IMyInterface

{

private int myint;

public MySample(int myint)

: base("hello, MyClass")

{

this.myint = myint;

}

[MyCustomAttribute]

private void Inc()

{

++myint;

}

protected virtual void EmptyVirtualMethod()

{

}

}

3.7 Инструкции (statements)

1. Каждая инструкция должна располагаться на отдельной строке.

2. Составные инструкции оформляются открывающей фигурной скобкой на отдельной

строке, списком инструкций, сдвинутым на одну табуляцию, и закрывающей фигурной

скобкой на отдельной строке.

3. После ключевого слова (напр. if, while, for) перед открывающей круглой скобкой (если

она есть) должен быть пробел.

13

3.7.1 Оформление If, if-else, if else-if else

if:

Верно  Неверно

if (condition)

{

DoSomething();

...

}

if(condition) DoSomething();

if(condition) {

DoSomething();

}

if (condition)

DoSomething();

if (condition)

{

DoSomething();

}

if с последующим else:

Верно Неверно

if (condition)

{

DoSomething();

...

}

else

{

DoSomethingOther();

...

}

if(condition) {

DoSomething();

...

} else {

DoSomethingOther();

...

}

if (condition)

DoSomething();

else

DoSomethingOther();

if (condition) DoSomething(); else

DoSomethingOther();

if-else:

Верно  Неверно

if (condition)

{

DoSomething();

...

}

else if (condition)

{

DoSomethingOther();

...

}

else

{

DoSomethingOtherAgain();

...

}

if (condition) {

DoSomething();

...

} else if (condition) {

DoSomethingOther();

...

} else {

DoSomethingOtherAgain();

...

}

3.7.2 Оформление for, foreach

for:

Верно  Неверно

for (int i = 0; i < 5; ++i)

{

...

}

for(int i = 0; i < 5; ++i) {

...

}

for с  пустым  телом:

14

Верно  Неверно

for (initialization; condition; update)

;

for(initialization; condition; update);

foreach:

Верно  Неверно

foreach (int i in IntList)

{

...

}

foreach(int i in IntList) {

...

}

3.7.3 Оформление while, do-while

while:

Верно  Неверно

while (condition)

{

...

}

while(condition) {

...

}

while с пустым телом:

Верно Неверно

while (condition)

;

while(condition);

do-while:

Верно  Неверно

do

{

...

}

while (condition);

do {

...

} while(condition);

3.7.4 Оформление switch

switch с длинными последовательностями в case:

Верно  Неверно

switch (condition)

{

case 1:

case 2:

x = ...;

break;

case 3:

x = ...;

break;

default:

x = ...;

break;

}

switch(condition) {

case 1:

case 2:

x = ...;

break;

case 3:

x = ...;

break;

default:

x = ...;

break;

}

switch с короткими последовательностями в case:

Верно  Неверно

switch (condition)

{

case 1: x = 1; break;

case 2: x = 2; break;

case 3: x = 3; break;

switch(condition) {

case 1: x = 1; break;

case 2: x = 2; break;

case 3: x = 3; break;

default: x = 100; break;

15

default: x = 100; break;

}

}

3.7.5 Оформление try-catch

try-catch без конкретного исключения:

Верно Неверно

try

{

...

}

catch

{

...

}

try {

...

} catch {

...

}

try-catch с фильтром исключений:

Верно  Неверно

try

{

...

}

catch (Exception ex)

{

...

}

try {

...

} catch(Exception ex) {

...

}

try-catch с  фильтром  исключений  и  блоком finally:

Верно  Неверно

try

{

...

}

catch (SomeException ex)

{

...

}

catch (Exception ex)

{

...

}

finally

{

...

}

try {

...

} catch(SomeException ex) {

...

} catch(Exception ex) {

...

} finally {

...

}

3.7.6 Оформление инструкции using

Одиночный using:

Верно  Неверно

using (initialization)

{

...

}

using(initialization) {

...

}

Вложенные using:

Верно  Неверно

using (initialization1)

using (initialization2)

{

...

}

using(initialization1)

using(initialization2) {

...

}

16

4 Общие  правила  разработки  классов

1. Допускается определять в классе публичные (public и internal) поля, но они должны

однозначно интерпретироваться как lightweight-поля. Оформляйте их стилем Паскаль и

указывайте в документации, что не следует передавать такие поля по ссылке. Старайтесь

(если, конечно, на то нет особых причин) избегать смешивания в одном классе/структуре

публичных полей и свойств.

2. Старайтесь реализовать в виде свойств только то, что отражает состояние класса или

объекта. Например, если вы делаете свою коллекцию, то количество элементов (Count)

должно быть свойством, а операцию преобразования ее в массив (GetArray) лучше

сделать методом. Причем вместо Get в данном случае лучше использовать другое слово,

например, ToXxxx. То есть метод будет называться ToArray().

3. Используйте методы, если выполняемая операция является преобразованием, имеет

побочный эффект или долго выполняется.

4. Используйте метод, если важен порядок выполнения операций.

5. Свойство не должно менять своего значения от вызова к вызову, если состояние объекта

не изменяется. Если результат при новом вызове может быть другим при том же

состоянии объекта, используйте метод.

6. Не используйте свойства «только для записи». Потребность в таком свойстве может быть

признаком плохого проектирования.

7. Запечатанные (sealed) классы не должны иметь ни защищенных, ни виртуальных

методов. Такие методы используются в производных классах, а sealed-класс не может

быть базовым.

8. Классы, реализующие интерфейс IDisposable, ни в коем случае не должны передаваться

по значению.

9. Классы, определяющие только статические методы и свойства, не должны иметь открытых

или защищенных конструкторов, поскольку никогда не нужно создавать их экземпляры.

10. Не используйте литеральные константы (магические числа, зашитые в код размеры

буферов, времена ожидания и тому подобное). Лучше определите константу (если вы

никогда не будете ее менять) или переменную только для чтения (если она может

измениться в будущих версиях вашего класса).

11. Старайтесь обрабатывать только известные вам исключения. Если вы все же

обрабатываете все исключения, то или, проведя необходимую обработку, генерируйте

исключение повторно, чтобы его могли обработать последующие фильтры, или выводите

пользователю максимально полную информацию об ошибке. Если целью перехвата

исключений является очистка ресурсов после сбоя, лучше воспользоваться секцией

finally
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNTE4MjA5ODFdfQ==
-->